function [ W1, b1,  W2,  b2, ...
           pW1n,pb1n, pW2n, pb2n, ...
           gW1n, gb1n, gW2n, gb2n, ...
           iteration, index] = ...
                        conjugateTrain( P, T, ...
                                        W1, b1, W2, b2, ...
                                        pW1, pb1, pW2, pb2, ...
                                        gW1,gb1, gW2, gb2, ...
                                        iteration, isGraph)
%important constants for training

epsilon = 0.001;         %rate to increase search interval
startingRate =  0.000;     %minimum jump
%reset search direction every n iterations
R = size(P,1);
s1 = size(W1,1);
s2 = size(W2,1);
resetPeriod = R*s2 + s2 + s2*s1 + s1;  
%select an interval to minimize
[a, b] = getInterval( @(rate) perfIndex(    W1 + rate*pW1, ...
                                b1 + rate*pb1, ...
                                W2 + rate*pW2, ...
                                b2 + rate*pb2, ...
                                P,T), ...
                                startingRate, epsilon);
%minizize the interval to tolerance
rate = golden(@(rate) perfIndex(    W1 + rate*pW1, ...
                                b1 + rate*pb1, ...
                                W2 + rate*pW2, ...
                                b2 + rate*pb2, ...
                                P,T),...
                                a, b);
%conjugate gradient weight update
W1 = W1 + rate*pW1;     b1 = b1 + rate*pb1;
W2 = W2 + rate*pW2;     b2 = b2 + rate*pb2;
%get error
index = perfIndex(  W1 + rate*pW1, ... 
                    b1 + rate*pb1, ... 
                    W2 + rate*pW2, ... 
                    b2 + rate*pb2, ... 
                    P, T);
if isGraph
    fprintf('\tconjugate performance index: %f,    learning rate: %f\n',index, rate)
end
[gW1n, gb1n, gW2n, gb2n] = accumulateGradients( W1, b1, W2, b2, P, T );
iteration = iteration +1;
%get directional gain
if mod(iteration, resetPeriod) == 0
    bW1 = 0;    bb1 = 0;
    bW2 = 0;    bb2 = 0;
else
    %decide how much of the new gradient to "mix" based on magnitude
    %uses fletcher reeves update
    bW1 = getGains(gW1n, gW1);    bb1 = getGains(gb1n, gb1);
    bW2 = getGains(gW2n, gW2);    bb2 = getGains(gb2n, gb2);
end
%calculate new directions
pW1n = -gW1n + pW1*bW1;    pb1n = -gb1n + pb1*bb1;
pW2n = -gW2n + pW2*bW2;    pb2n = -gb2n + pb2*bb2;
end




